/*
 * sboy: simple gameboy emulator
 * Copyright (C) 2014-2018 Thomas Spurden <thomas@spurden.name>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include <SDL2/SDL.h>

#include "gameboy.h"
#include "utils.h"

// Choose your joystick index.
#define JoyIndex 0

// List the buttons in order (see jstest output) and the X11 keysym you want to
// be generated by it (or zero for no keysym).  To work out your buttons just
// compile with verbose on; each button press will be printed to stdout.
#define KEYS \
	KEY(Select, Button_Select), \
	KEY(LClick, 0), \
	KEY(RClick, 0), \
	KEY(Start, Button_Start), \
	KEY(Up, Button_Up), \
	KEY(Right, Button_Right), \
	KEY(Down, Button_Down), \
	KEY(Left, Button_Left), \
	KEY(L2, 0), \
	KEY(R2, 0), \
	KEY(L1, 0), \
	KEY(R1, 0), \
	KEY(Triangle, 0), \
	KEY(Circle, Button_A), \
	KEY(Cross, Button_B), \
	KEY(Square, 0), \
	KEY(PS, 0)

#define KEY(k,x) Key_ ## k
enum Key {
	KEYS,
	Keys_Num
};
#undef KEY

#define KEY(k,x) [Key_ ## k] = x
static int const buttonMap[Keys_Num] = {
	KEYS
};
#undef KEY
#undef KEYS

unsigned int g_frameDelay = 0;

int PollEvents(struct Gameboy* gb)
{
	SDL_Event event;
	while(SDL_PollEvent(&event)) {
		int key = 0;
		bool up = false;
		switch(event.type) {
			case SDL_JOYBUTTONDOWN:
			case SDL_JOYBUTTONUP:
			{
				int const n = event.jbutton.button;
				if(n < Keys_Num && buttonMap[n]) {
					gameboy_setButtonState(gb, buttonMap[n], event.type == SDL_JOYBUTTONDOWN);
				}
				break;
			}
			case SDL_KEYUP:
				up = true;
				// fallthrough
			case SDL_KEYDOWN:
				switch(event.key.keysym.sym) {
					case SDLK_UP:
						key = Button_Up;
						break;
					case SDLK_DOWN:
						key = Button_Down;
						break;
					case SDLK_LEFT:
						key = Button_Left;
						break;
					case SDLK_RIGHT:
						key = Button_Right;
						break;
					case SDLK_RETURN:
						key = Button_Start;
						break;
					case SDLK_TAB:
						key = Button_Select;
						break;
					case SDLK_LALT:
						key = Button_A;
						break;
					case SDLK_LCTRL:
						key = Button_B;
						break;
					case SDLK_ESCAPE:
						return 1;
						break;
					case SDLK_s:
						g_frameDelay = up? 0 : 1000;
						break;
					default:
						break;
				}
				break;
			case SDL_QUIT:
				return 1;
				break;
			default:
				break;
		}

		if(key) {
			gameboy_setButtonState(gb, key, !up);
		}
	}

	return 0;
}

int main(int argc, char** argv)
{
	if(argc < 2) {
		fprintf(stderr, "Usage: sboy <romfile> [<savefile>]\n");
		return EXIT_FAILURE;
	}

	char const* saveFilename = NULL;
	if(argc > 2) {
		saveFilename = argv[2];
	}

	static struct Gameboy gb;

	if(LoadROM(&gb, argv[1])) {
		fprintf(stderr, "Could not load ROM\n");
		return EXIT_FAILURE;
	}

	char const* loadError = gameboy_load(&gb);
	if(loadError) {
		fprintf(stderr, "ROM Invalid: %s\n", loadError);
		return EXIT_FAILURE;
	}

	if(saveFilename && gb.info.HasBattery && gb.mem.CartRAMSize) {
		if(LoadRAM(&gb, saveFilename)) {
			fprintf(stderr, "Could not load RAM from \"%s\"\n", saveFilename);
		}
	}

	if(SDL_Init(SDL_INIT_VIDEO|SDL_INIT_TIMER|SDL_INIT_JOYSTICK)) {
		fprintf(stderr, "SDL_Init failed: %s\n", SDL_GetError());
		return EXIT_FAILURE;
	}

	atexit(SDL_Quit);

	if(SDL_JoystickEventState(SDL_ENABLE) == -1) {
		fprintf(stderr, "SDL_JoystickEventState(SDL_ENABLE) failed: %s\n", SDL_GetError());
		return EXIT_FAILURE;
	}

	SDL_Joystick* joystick = SDL_JoystickOpen(JoyIndex);
	if(joystick == NULL) {
		fprintf(stderr, "Could not open joystick %i: %s\n", JoyIndex, SDL_GetError());
	}

	SDL_Window* window = SDL_CreateWindow("SBoy", SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED, 800, 600, SDL_WINDOW_RESIZABLE);
	if(!window) {
		fprintf(stderr, "SDL_CreateWindow failed: %s\n", SDL_GetError());
		return EXIT_FAILURE;
	}

	SDL_Renderer* renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_PRESENTVSYNC);
	if(!renderer) {
		fprintf(stderr, "SDL_CreateRenderer failed: %s\n", SDL_GetError());
		return EXIT_FAILURE;
	}

	SDL_Texture* frameTexture = SDL_CreateTexture(renderer, SDL_PIXELFORMAT_ARGB8888, SDL_TEXTUREACCESS_STREAMING, 160, 144);
	if(!frameTexture) {
		fprintf(stderr, "SDL_CreateTexture failed: %s\n", SDL_GetError());
		return EXIT_FAILURE;
	}

	SDL_SetRenderDrawColor(renderer, 255, 255, 255, 255);
	SDL_RenderClear(renderer);
	SDL_RenderPresent(renderer);

	SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "best");
	SDL_RenderSetLogicalSize(renderer, 160, 144);

	uint32_t palette[4] = { 0xFFFFFFFF, 0xFFAAAAAA, 0xFF555555, 0xFF000000 };
	uint32_t frame[144][160];

	gameboy_reset(&gb, true);

	uint64_t lastKeyCheck = 0;
	while(gameboy_step(&gb) == 0) {
		if(gb.lcd.NewFrame) {
			gb.lcd.NewFrame = false;
			for(unsigned int y = 0; y < 144; y += 1) {
				for(unsigned int x = 0; x < 160; x += 1) {
					uint8_t pixel = gb.lcd.Buffer[x][y];
					frame[y][x] = palette[pixel & 0x03];
				}
			}
			SDL_UpdateTexture(frameTexture, NULL, frame, 160 * sizeof(uint32_t));
			SDL_RenderClear(renderer);
			SDL_RenderCopy(renderer, frameTexture, NULL, NULL);
			SDL_RenderPresent(renderer);
			SDL_Delay(g_frameDelay);
		}

		if((gb.TotalCycles - lastKeyCheck) > 4096) {
			lastKeyCheck = gb.TotalCycles;
			if(PollEvents(&gb)) {
				if(saveFilename && gb.info.HasBattery && gb.mem.CartRAMSize) {
					if(SaveRAM(&gb, saveFilename)) {
						fprintf(stderr, "Could not save RAM to \"%s\"\n", saveFilename);
						exit(EXIT_FAILURE);
					}
				}
				return (EXIT_SUCCESS);
			}
		}
	}

	if(joystick) {
		SDL_JoystickClose(joystick);
	}

	return EXIT_FAILURE;
}
